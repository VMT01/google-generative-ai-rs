use std::collections::HashMap;

use super::schema::Schema as FunctionDeclarationSchema;

/// Tool details that the model may use to generate response.
///
/// A `Tool` is a piece of code that enables the system to interact with external systems
/// to perform an action, or set of actions, outside of knowledge and scope of the model.
#[derive(Debug, Clone, serde::Serialize)]
pub struct Tool {
    /// A list of [FunctionDeclaration] available to the model that can be used for function calling.
    /// The model or system does not execute the function.
    /// Instead the defined function may be returned as a [FunctionCall] part with arguments to the client side for execution.
    /// The next conversation turn may contain a [FunctionResponse] with the role "function" generation context for the next model turn.
    pub function_declarations: Option<Vec<FunctionDeclaration>>,

    /// Enables the model to execute code as part of generation.
    pub code_execution: Option<CodeExecution>,
}

/// FunctionDeclaration is structured representation of a function declaration as defined by the [OpenAPI 3.03 specification](https://spec.openapis.org/oas/v3.0.3).
/// Include in this declaration are the function name and parameters.
/// This [FunctionDeclaration] is a representation of a block of code that can be used as a `Tool` by the model and executed by the client.
#[derive(Debug, Clone, serde::Serialize)]
pub struct FunctionDeclaration {
    /// The name of the function.
    /// Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
    pub name: String,

    /// A brief description of the function.
    pub description: String,

    /// Describes the parameters to this function.
    /// Reflects the Open API 3.03 Parameter Object
    /// - { string } Key: the name of the parameter. Parameter names are case sensitive.
    /// - { Schema } Value: the Schema defining the type used for the parameter.
    pub parameters: Option<FunctionDeclarationSchema>,
}

/// [CodeExecution] is tool that executes code generated by the model, and automatically returns the result to the model.
///
/// See also [ExecutableCode] and [CodeExecutionResult] which are only generated when using this tool.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CodeExecution;

/// [ToolConfig] is the Tool configuration containing parameters for specifying [Tool] use in the request.
#[derive(Debug, Clone, serde::Serialize)]
pub struct ToolConfig {
    pub function_calling_config: FunctionCalingConfig,
}

/// FunctionCallingConfig holds configuration for function calling.
#[derive(Debug, Clone, serde::Serialize)]
pub struct FunctionCalingConfig {
    /// Specifies the mode in which function calling should execute.
    /// If unspecified, the default value will be set to AUTO.
    pub mode: Option<FunctionCallingMode>,

    /// A set of function names that, when provided, limits the functions the model will call.
    ///
    /// This should only be set when the Mode is ANY.
    /// Function names should match [FunctionDeclaration::name].
    /// With mode set to ANY, model will predict a function call from the set of function names provided.
    pub allowed_function_names: Option<Vec<String>>,
}
/// FunctionCallingMode is defines the execution behavior for function calling by defining the execution mode.
#[derive(Debug, Clone, serde::Serialize)]
pub enum FunctionCallingMode {
    /// Unspecified function calling mode. This value should not be used.
    ModeUnspecified,

    /// Default model behavior, model decides to predict either a function call or a natural language repspose.
    Auto,

    /// Model is constrained to always predicting a function call only.
    /// If [allowed_function_names][FunctionCalingConfig::allowed_function_names] are set, the predicted function call will be limited to any one of allowed_function_names,
    /// else the predicted function call will be any one of the provided [function_declarations][Tool::function_declarations].
    Any,

    /// Model will not predict any function call. Model behavior is same as when not passing any function declarations.
    None,
}

/// The base structured datatype containing multi-part content of a message.
/// A [Content] includes a [role][Content::role] field designating the producer of the [Content] and a [parts][Content::parts] field containing multi-part data that contains the content of the message turn.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Content {
    /// The producer of the content. Must be either 'user' or 'model'.
    ///
    /// Useful to set for multi-turn conversations, otherwise can be left blank or unset.
    pub role: Role,

    /// Ordered `Parts` that constitute a single message. Parts may have different MIME types.
    pub parts: Vec<Part>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum Role {
    #[serde(rename = "user")]
    User,
    #[serde(rename = "model")]
    Model,
}

/// A Part is a piece of model content.
#[derive(Debug, Default, Clone, serde::Serialize, serde::Deserialize)]
pub struct Part {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub inline_data: Option<GenerativeContentBlob>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub function_call: Option<FunctionCall>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub function_response: Option<FunctionResponse>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_data: Option<FileData>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub executable_code: Option<ExecutableCode>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code_execution_result: Option<CodeExecutionResult>,
}

/// Interface for sending an image.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct GenerativeContentBlob {
    pub mime_type: String,

    /// Image as a base64 string.
    pub data: String,
}

/// FunctionCall is a predicted [FunctionCall] returned from the model that contains a string representing the [FunctionDeclaration::name] with the arguments and their values.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct FunctionCall {
    /// The name of the function to call.
    /// Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
    pub name: String,

    /// The function parameters and values in JSON object format.
    pub args: HashMap<String, serde_json::Value>,
}

/// FunctionResponse is the result output from a [FunctionCall] that contains a string representing the [FunctionDeclaration::name] and a structured JSON object containing any output from the function is used as context to the model.
/// This should contain the result of a [FunctionCall] made based on model prediction.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct FunctionResponse {
    /// The name of the function to call.
    /// Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
    pub name: String,

    /// The function response in JSON object format.
    pub response: HashMap<String, serde_json::Value>,
}

/// FileData is URI based data.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct FileData {
    /// The IANA standard MIME type of the source data.
    pub mime_type: String,
    pub uri: String,
}

/// ExecutableCode is code generated by the model that is meant to be executed, and the result returned to the model.
///
/// Only generated when using the [CodeExecution] tool, in which the code will be automatically executed, and a corresponding [CodeExecutionResult] will also be generated.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ExecutableCode {
    /// The code to be executed.
    pub code: String,

    /// Programming language of the [code][ExecutableCode::code].
    pub language: ExecutableCodeLanguage,
}

/// ExecutableCodeLanguage is supported programming languages for the generated code.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum ExecutableCodeLanguage {
    LanguageUnspecified,
    Python,
}

/// CodeExecutionResult is result of executing the [ExecutableCode].
///
/// Only generated when using the [CodeExecution], and always follows a [Part] containing the [ExecutableCode].
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CodeExecutionResult {
    /// Outcome of the code execution.
    pub outcome: CodeExecutionResultOutcome,

    /// Contains stdout when code execution is successful, stderr or other description otherwise.
    pub output: String,
}

/// CodeExecutionResultOutcome is enumeration of possible outcomes of the code execution.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum CodeExecutionResultOutcome {
    /// Unspecified status. This value should not be used.
    Unspecified,

    /// Code execution completed successfully.
    Ok,

    /// Code execution finished but with a failure. `stderr` should contain the reason.
    Failed,

    /// Code execution ran for too long, and was cancelled.
    /// There may or may not be a partial output present.
    DeadlineExceeded,
}
